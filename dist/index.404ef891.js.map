{"mappings":"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","sources":["<anon>","brolang.js","ast.js","lexer.js","analyzer.js"],"sourcesContent":["class $bcf4dc5857a381cb$var$ASTNode {\n    constructor(type, value){\n        this.type = type;\n        this.value = value;\n        this.children = [];\n    }\n}\nclass $bcf4dc5857a381cb$export$7acfa6ed01010e37 {\n    constructor(tokens){\n        this.tokens = tokens;\n        this.position = 0;\n    }\n    parse() {\n        const root = new $bcf4dc5857a381cb$var$ASTNode(\"Program\", null);\n        while(this.position < this.tokens.length)root.children.push(this._parseStatement());\n        return root;\n    }\n    _parseStatement() {\n        const token = this.tokens[this.position];\n        if (token.type === \"IDENTIFIER\") return this._parseExpression();\n        throw new Error(`Unexpected token: ${token.type}`);\n    }\n    _parseExpression() {\n        const token = this.tokens[this.position++];\n        const node = new $bcf4dc5857a381cb$var$ASTNode(\"Expression\", token.value);\n        if (this.tokens[this.position] && this.tokens[this.position].type === \"PLUS\") {\n            this.position++;\n            node.children.push(this._parseExpression());\n        }\n        return node;\n    }\n}\n\n\nclass $df8b4d8c99c86b58$export$6168dc8908a6c652 {\n    constructor(input){\n        this.input = input;\n        this.position = 0;\n        this.tokens = [];\n    }\n    tokenize() {\n        while(this.position < this.input.length){\n            let char = this.input[this.position];\n            if (/\\s/.test(char)) {\n                this.position++;\n                continue;\n            }\n            switch(char){\n                case \";\":\n                    this._addToken(\"SEMICOLON\", char);\n                    break;\n                case \"+\":\n                    this._addToken(\"PLUS\", char);\n                    break;\n                default:\n                    if (/[a-zA-Z]/.test(char)) this.tokens.push(this._readIdentifier());\n                    else if (/\\d/.test(char)) this.tokens.push(this._readNumber());\n                    else throw new Error(`Unexpected character: ${char}`);\n            }\n        }\n        return this.tokens;\n    }\n    _addToken(type, value) {\n        this.tokens.push({\n            type: type,\n            value: value\n        });\n        this.position++;\n    }\n    _readIdentifier() {\n        let start = this.position;\n        while(/[a-zA-Z]/.test(this.input[this.position]))this.position++;\n        let value = this.input.slice(start, this.position);\n        return {\n            type: \"IDENTIFIER\",\n            value: value\n        };\n    }\n    _readNumber() {\n        let start = this.position;\n        while(/\\d/.test(this.input[this.position]))this.position++;\n        let value = this.input.slice(start, this.position);\n        return {\n            type: \"NUMBER\",\n            value: value\n        };\n    }\n}\n\n\nclass $b96d835da55fc0cb$export$703935dce4376685 {\n    constructor(ast){\n        this.ast = ast;\n    }\n    analyze() {\n        this._checkNode(this.ast);\n    }\n    _checkNode(node) {\n        if (node.type === \"Program\") node.children.forEach((child)=>this._checkNode(child));\n        else if (node.type === \"Expression\") {\n            // Example check: ensure identifiers are defined\n            if (!this._isDefined(node.value)) throw new Error(`Undefined identifier: ${node.value}`);\n            node.children.forEach((child)=>this._checkNode(child));\n        }\n    }\n    _isDefined(identifier) {\n        // Placeholder for checking if an identifier is defined\n        return true;\n    }\n}\n\n\nconst $959637dd9f50fb12$var$sourceCode = `yo a = 5; yo b = a + 10;`;\nconst $959637dd9f50fb12$var$lexer = new (0, $df8b4d8c99c86b58$export$6168dc8908a6c652)($959637dd9f50fb12$var$sourceCode);\nconst $959637dd9f50fb12$var$tokens = $959637dd9f50fb12$var$lexer.tokenize();\nconst $959637dd9f50fb12$var$parser = new (0, $bcf4dc5857a381cb$export$7acfa6ed01010e37)($959637dd9f50fb12$var$tokens);\nconst $959637dd9f50fb12$var$ast = $959637dd9f50fb12$var$parser.parse();\nconst $959637dd9f50fb12$var$semanticAnalyzer = new (0, $b96d835da55fc0cb$export$703935dce4376685)($959637dd9f50fb12$var$ast);\n$959637dd9f50fb12$var$semanticAnalyzer.analyze();\n\n\n//# sourceMappingURL=index.404ef891.js.map\n","import { Parser } from \"./ast\";\nimport { Lexer } from \"./lexer\";\nimport { SemanticAnalyzer } from \"./analyzer\";\n\nconst sourceCode = `yo a = 5; yo b = a + 10;`;\nconst lexer = new Lexer(sourceCode);\nconst tokens = lexer.tokenize();\nconst parser = new Parser(tokens);\nconst ast = parser.parse();\nconst semanticAnalyzer = new SemanticAnalyzer(ast);\nsemanticAnalyzer.analyze();\n","class ASTNode {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n    this.children = [];\n  }\n}\n\nexport class Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.position = 0;\n  }\n\n  parse() {\n    const root = new ASTNode(\"Program\", null);\n    while (this.position < this.tokens.length) {\n      root.children.push(this._parseStatement());\n    }\n    return root;\n  }\n\n  _parseStatement() {\n    const token = this.tokens[this.position];\n    if (token.type === \"IDENTIFIER\") {\n      return this._parseExpression();\n    }\n    throw new Error(`Unexpected token: ${token.type}`);\n  }\n\n  _parseExpression() {\n    const token = this.tokens[this.position++];\n    const node = new ASTNode(\"Expression\", token.value);\n    if (\n      this.tokens[this.position] &&\n      this.tokens[this.position].type === \"PLUS\"\n    ) {\n      this.position++;\n      node.children.push(this._parseExpression());\n    }\n    return node;\n  }\n}\n","export class Lexer {\n    constructor(input) {\n      this.input = input;\n      this.position = 0;\n      this.tokens = [];\n    }\n  \n    tokenize() {\n      while (this.position < this.input.length) {\n        let char = this.input[this.position];\n  \n        if (/\\s/.test(char)) {\n          this.position++;\n          continue;\n        }\n  \n        switch (char) {\n          case ';':\n            this._addToken('SEMICOLON', char);\n            break;\n          case '+':\n            this._addToken('PLUS', char);\n            break;\n          default:\n            if (/[a-zA-Z]/.test(char)) {\n              this.tokens.push(this._readIdentifier());\n            } else if (/\\d/.test(char)) {\n              this.tokens.push(this._readNumber());\n            } else {\n              throw new Error(`Unexpected character: ${char}`);\n            }\n        }\n      }\n      return this.tokens;\n    }\n  \n    _addToken(type, value) {\n      this.tokens.push({ type, value });\n      this.position++;\n    }\n  \n    _readIdentifier() {\n      let start = this.position;\n      while (/[a-zA-Z]/.test(this.input[this.position])) {\n        this.position++;\n      }\n      let value = this.input.slice(start, this.position);\n      return { type: 'IDENTIFIER', value };\n    }\n  \n    _readNumber() {\n      let start = this.position;\n      while (/\\d/.test(this.input[this.position])) {\n        this.position++;\n      }\n      let value = this.input.slice(start, this.position);\n      return { type: 'NUMBER', value };\n    }\n  }\n  ","export class SemanticAnalyzer {\n  constructor(ast) {\n    this.ast = ast;\n  }\n\n  analyze() {\n    this._checkNode(this.ast);\n  }\n\n  _checkNode(node) {\n    if (node.type === \"Program\") {\n      node.children.forEach((child) => this._checkNode(child));\n    } else if (node.type === \"Expression\") {\n      // Example check: ensure identifiers are defined\n      if (!this._isDefined(node.value)) {\n        throw new Error(`Undefined identifier: ${node.value}`);\n      }\n      node.children.forEach((child) => this._checkNode(child));\n    }\n  }\n\n  _isDefined(identifier) {\n    // Placeholder for checking if an identifier is defined\n    return true;\n  }\n}\n"],"names":["$bcf4dc5857a381cb$var$ASTNode","constructor","type","value","children","$959637dd9f50fb12$var$tokens","$959637dd9f50fb12$var$lexer","input","position","tokens","tokenize","length","char","test","_addToken","push","_readIdentifier","_readNumber","Error","start","slice","$959637dd9f50fb12$var$ast","$959637dd9f50fb12$var$parser","parse","root","_parseStatement","token","_parseExpression","node","$959637dd9f50fb12$var$semanticAnalyzer","ast","analyze","_checkNode","forEach","child","_isDefined","identifier"],"version":3,"file":"index.404ef891.js.map"}