{"mappings":"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","sources":["<anon>","brolang.js","lexer.js","ast.js","analyzer.js","interpreter.js"],"sourcesContent":["class $df8b4d8c99c86b58$export$6168dc8908a6c652 {\n    constructor(input){\n        this.input = input;\n        this.position = 0;\n        this.tokens = [];\n    }\n    tokenize() {\n        while(this.position < this.input.length){\n            let char = this.input[this.position];\n            if (/\\s/.test(char)) {\n                this.position++;\n                continue;\n            }\n            switch(char){\n                case \";\":\n                    this._addToken(\"SEMICOLON\", char);\n                    break;\n                case \"+\":\n                    this._addToken(\"PLUS\", char);\n                    break;\n                case \"-\":\n                    this._addToken(\"MINUS\", char);\n                    break;\n                case \"*\":\n                    this._addToken(\"MULTIPLY\", char);\n                    break;\n                case \"/\":\n                    this._addToken(\"DIVIDE\", char);\n                    break;\n                case \"%\":\n                    this._addToken(\"MODULO\", char);\n                    break;\n                case \"=\":\n                    this._addToken(\"EQUALS\", char);\n                    break;\n                case \">\":\n                    this._addToken(\"GREATER_THAN\", char);\n                    break;\n                case \"<\":\n                    this._addToken(\"LESS_THAN\", char);\n                    break;\n                case \"{\":\n                    this._addToken(\"LBRACE\", char);\n                    break;\n                case \"}\":\n                    this._addToken(\"RBRACE\", char);\n                    break;\n                case \"(\":\n                    this._addToken(\"LPAREN\", char);\n                    break;\n                case \")\":\n                    this._addToken(\"RPAREN\", char);\n                    break;\n                case \"[\":\n                    this._addToken(\"LBRACKET\", char);\n                    break;\n                case \"]\":\n                    this._addToken(\"RBRACKET\", char);\n                    break;\n                case \",\":\n                    this._addToken(\"COMMA\", char);\n                    break;\n                case '\"':\n                    this.tokens.push(this._readString());\n                    break;\n                default:\n                    if (/[a-zA-Z]/.test(char)) this.tokens.push(this._readIdentifierOrKeyword());\n                    else if (/\\d/.test(char)) this.tokens.push(this._readNumber());\n                    else throw new Error(`Unexpected character: ${char}`);\n            }\n        }\n        return this.tokens;\n    }\n    _addToken(type, value) {\n        this.tokens.push({\n            type: type,\n            value: value\n        });\n        this.position++;\n    }\n    _readIdentifierOrKeyword() {\n        let start = this.position;\n        while(/[a-zA-Z]/.test(this.input[this.position]))this.position++;\n        let value = this.input.slice(start, this.position);\n        const keywords = [\n            \"yo\",\n            \"brofunc\",\n            \"bounce\",\n            \"spill\",\n            \"if\",\n            \"else\",\n            \"forEvery\",\n            \"squadGoals\",\n            \"dope\",\n            \"nope\"\n        ];\n        const type = keywords.includes(value) ? \"KEYWORD\" : \"IDENTIFIER\";\n        return {\n            type: type,\n            value: value\n        };\n    }\n    _readNumber() {\n        let start = this.position;\n        while(/\\d/.test(this.input[this.position]))this.position++;\n        let value = this.input.slice(start, this.position);\n        return {\n            type: \"NUMBER\",\n            value: value\n        };\n    }\n    _readString() {\n        let start = ++this.position; // Skip the opening quote\n        while(this.input[this.position] !== '\"')this.position++;\n        let value = this.input.slice(start, this.position);\n        this.position++; // Skip the closing quote\n        return {\n            type: \"STRING\",\n            value: value\n        };\n    }\n}\n\n\nclass $bcf4dc5857a381cb$var$ASTNode {\n    constructor(type, value){\n        this.type = type;\n        this.value = value;\n        this.children = [];\n    }\n}\nclass $bcf4dc5857a381cb$export$7acfa6ed01010e37 {\n    constructor(tokens){\n        this.tokens = tokens;\n        this.position = 0;\n    }\n    parse() {\n        const root = new $bcf4dc5857a381cb$var$ASTNode(\"Program\", null);\n        while(this.position < this.tokens.length)root.children.push(this._parseStatement());\n        return root;\n    }\n    _parseStatement() {\n        const token = this.tokens[this.position];\n        console.log(`Parsing statement at position ${this.position}: ${token ? token.type : \"EOF\"}`);\n        switch(token.type){\n            case \"KEYWORD\":\n                return this._parseKeywordStatement();\n            case \"IDENTIFIER\":\n                return this._parseExpressionStatement();\n            default:\n                throw new Error(`Unexpected token: ${token.type}`);\n        }\n    }\n    _parseKeywordStatement() {\n        const token = this.tokens[this.position++];\n        let statementNode;\n        switch(token.value){\n            case \"yo\":\n                statementNode = this._parseVariableDeclaration();\n                break;\n            case \"brofunc\":\n                statementNode = this._parseFunctionDeclaration();\n                break;\n            case \"spill\":\n                statementNode = this._parsePrintStatement();\n                break;\n            case \"if\":\n                statementNode = this._parseIfStatement();\n                break;\n            case \"forEvery\":\n                statementNode = this._parseForEachLoop();\n                break;\n            case \"squadGoals\":\n                statementNode = this._parseConcurrencyBlock();\n                break;\n            default:\n                throw new Error(`Unexpected keyword: ${token.value}`);\n        }\n        this._consume(\"SEMICOLON\");\n        return statementNode;\n    }\n    _parseVariableDeclaration() {\n        const identifierToken = this.tokens[this.position++];\n        this._consume(\"EQUALS\");\n        const expressionNode = this._parseExpression();\n        return new $bcf4dc5857a381cb$var$ASTNode(\"VariableDeclaration\", {\n            identifier: identifierToken.value,\n            expression: expressionNode\n        });\n    }\n    _parseFunctionDeclaration() {\n        const nameToken = this.tokens[this.position++];\n        const params = this._parseParameters();\n        const body = this._parseBlock();\n        return new $bcf4dc5857a381cb$var$ASTNode(\"FunctionDeclaration\", {\n            name: nameToken.value,\n            parameters: params,\n            body: body\n        });\n    }\n    _parsePrintStatement() {\n        const expressionNode = this._parseExpression();\n        if (!expressionNode) throw new Error(\"Failed to parse expression for spill statement\");\n        return new $bcf4dc5857a381cb$var$ASTNode(\"PrintStatement\", {\n            expression: expressionNode\n        });\n    }\n    _parseIfStatement() {\n        const condition = this._parseExpression();\n        const thenBranch = this._parseBlock();\n        let elseBranch = null;\n        if (this._match(\"KEYWORD\", \"else\")) elseBranch = this._parseBlock();\n        return new $bcf4dc5857a381cb$var$ASTNode(\"IfStatement\", {\n            condition: condition,\n            thenBranch: thenBranch,\n            elseBranch: elseBranch\n        });\n    }\n    _parseForEachLoop() {\n        const elementToken = this.tokens[this.position++];\n        this._consume(\"KEYWORD\", \"in\");\n        const listToken = this.tokens[this.position++];\n        const body = this._parseBlock();\n        return new $bcf4dc5857a381cb$var$ASTNode(\"ForEachLoop\", {\n            element: elementToken.value,\n            list: listToken.value,\n            body: body\n        });\n    }\n    _parseConcurrencyBlock() {\n        const body = this._parseBlock();\n        return new $bcf4dc5857a381cb$var$ASTNode(\"ConcurrencyBlock\", body);\n    }\n    _parseExpressionStatement() {\n        const expressionNode = this._parseExpression();\n        this._consume(\"SEMICOLON\");\n        return new $bcf4dc5857a381cb$var$ASTNode(\"ExpressionStatement\", expressionNode);\n    }\n    _parseExpression() {\n        let left = this._parsePrimary();\n        while(this._check(\"PLUS\") || this._check(\"MINUS\") || this._check(\"MULTIPLY\") || this._check(\"DIVIDE\") || this._check(\"MODULO\")){\n            const operatorToken = this.tokens[this.position++];\n            const right = this._parsePrimary();\n            left = new $bcf4dc5857a381cb$var$ASTNode(\"BinaryExpression\", {\n                operator: operatorToken.value,\n                left: left,\n                right: right\n            });\n        }\n        return left;\n    }\n    _parsePrimary() {\n        const token = this.tokens[this.position++];\n        switch(token.type){\n            case \"IDENTIFIER\":\n                return new $bcf4dc5857a381cb$var$ASTNode(\"Identifier\", token.value);\n            case \"NUMBER\":\n            case \"STRING\":\n                return new $bcf4dc5857a381cb$var$ASTNode(\"Literal\", token.value);\n            default:\n                throw new Error(`Unexpected token in expression: ${token.type}`);\n        }\n    }\n    _parseParameters() {\n        const params = [];\n        this._consume(\"LPAREN\");\n        while(!this._check(\"RPAREN\")){\n            const paramToken = this.tokens[this.position++];\n            params.push(paramToken.value);\n            if (!this._check(\"RPAREN\")) this._consume(\"COMMA\");\n        }\n        this._consume(\"RPAREN\");\n        return params;\n    }\n    _parseBlock() {\n        this._consume(\"LBRACE\");\n        const statements = [];\n        while(!this._check(\"RBRACE\"))statements.push(this._parseStatement());\n        this._consume(\"RBRACE\");\n        return new $bcf4dc5857a381cb$var$ASTNode(\"Block\", statements);\n    }\n    _consume(expectedType, expectedValue = null) {\n        if (this.position >= this.tokens.length) throw new Error(`Unexpected end of input, expected token type ${expectedType}`);\n        const token = this.tokens[this.position];\n        if (token.type !== expectedType || expectedValue !== null && token.value !== expectedValue) throw new Error(`Expected token type ${expectedType} but found ${token.type}`);\n        this.position++;\n    }\n    _check(type) {\n        if (this.position >= this.tokens.length) return false;\n        return this.tokens[this.position].type === type;\n    }\n    _match(type, value) {\n        if (this._check(type) && this.tokens[this.position].value === value) {\n            this.position++;\n            return true;\n        }\n        return false;\n    }\n}\n\n\nclass $b96d835da55fc0cb$export$703935dce4376685 {\n    constructor(ast){\n        this.ast = ast;\n    }\n    analyze() {\n        this._checkNode(this.ast);\n    }\n    _checkNode(node) {\n        if (node.type === \"Program\") node.children.forEach((child)=>this._checkNode(child));\n        else if (node.type === \"Expression\") {\n            // Example check: ensure identifiers are defined\n            if (!this._isDefined(node.value)) throw new Error(`Undefined identifier: ${node.value}`);\n            node.children.forEach((child)=>this._checkNode(child));\n        }\n    }\n    _isDefined(identifier) {\n        // Placeholder for checking if an identifier is defined\n        return true;\n    }\n}\n\n\nclass $39fe91971e2ac260$export$e5b52c46a548ff03 {\n    constructor(){\n        this.variables = {};\n    }\n    interpret(ast) {\n        this._executeBlock(ast.children);\n    }\n    _executeBlock(statements) {\n        for (const statement of statements)this._execute(statement);\n    }\n    _execute(node) {\n        switch(node.type){\n            case \"Program\":\n                this._executeBlock(node.children);\n                break;\n            case \"VariableDeclaration\":\n                this._executeVariableDeclaration(node);\n                break;\n            case \"PrintStatement\":\n                this._executePrintStatement(node);\n                break;\n            case \"ExpressionStatement\":\n                this._evaluate(node.value);\n                break;\n            case \"IfStatement\":\n                this._executeIfStatement(node);\n                break;\n            case \"ForEachLoop\":\n                this._executeForEachLoop(node);\n                break;\n            case \"FunctionDeclaration\":\n                this._executeFunctionDeclaration(node);\n                break;\n            case \"ConcurrencyBlock\":\n                this._executeBlock(node.value.children); // Simplified for single-thread execution\n                break;\n            default:\n                throw new Error(`Unknown node type: ${node.type}`);\n        }\n    }\n    _executeVariableDeclaration(node) {\n        const value = this._evaluate(node.value.expression);\n        this.variables[node.value.identifier] = value;\n    }\n    _executePrintStatement(node) {\n        const value = this._evaluate(node.value.expression);\n        console.log(value);\n    }\n    _executeIfStatement(node) {\n        const condition = this._evaluate(node.value.condition);\n        if (condition) this._executeBlock(node.value.thenBranch.children);\n        else if (node.value.elseBranch) this._executeBlock(node.value.elseBranch.children);\n    }\n    _executeForEachLoop(node) {\n        const list = this.variables[node.value.list];\n        for (const item of list){\n            this.variables[node.value.element] = item;\n            this._executeBlock(node.value.body.children);\n        }\n    }\n    _executeFunctionDeclaration(node) {\n        // Store function in variables for later invocation\n        this.variables[node.value.name] = node;\n    }\n    _evaluate(node) {\n        if (!node) throw new Error(\"Attempted to evaluate a null or undefined node\");\n        console.log(\"Evaluating node:\", node);\n        switch(node.type){\n            case \"Literal\":\n                return node.value;\n            case \"BinaryExpression\":\n                return this._evaluateBinaryExpression(node);\n            case \"Identifier\":\n                return this.variables[node.value];\n            default:\n                throw new Error(`Unknown node type in evaluation: ${node.type}`);\n        }\n    }\n    _evaluateBinaryExpression(node) {\n        const left = this._evaluate(node.value.left);\n        const right = this._evaluate(node.value.right);\n        switch(node.value.operator){\n            case \"+\":\n                return left + right;\n            case \"-\":\n                return left - right;\n            case \"*\":\n                return left * right;\n            case \"/\":\n                return left / right;\n            case \"%\":\n                return left % right;\n            default:\n                throw new Error(`Unknown operator: ${node.value.operator}`);\n        }\n    }\n}\n\n\nfunction $959637dd9f50fb12$var$main() {\n    const sourceCode = `yo a = 5; yo b = a + 10; spill \"test\";`;\n    const lexer = new (0, $df8b4d8c99c86b58$export$6168dc8908a6c652)(sourceCode);\n    const tokens = lexer.tokenize();\n    console.log(\"Tokens:\", tokens);\n    const parser = new (0, $bcf4dc5857a381cb$export$7acfa6ed01010e37)(tokens);\n    const ast = parser.parse();\n    console.log(JSON.stringify(ast, null, 2)); // Debugging: Print the AST structure\n    const semanticAnalyzer = new (0, $b96d835da55fc0cb$export$703935dce4376685)(ast);\n    semanticAnalyzer.analyze();\n    console.log(\"Semantic analysis completed successfully.\");\n    const interpreter = new (0, $39fe91971e2ac260$export$e5b52c46a548ff03)();\n    interpreter.interpret(ast);\n}\n$959637dd9f50fb12$var$main();\n\n\n//# sourceMappingURL=index.4c084828.js.map\n","import { Lexer } from \"./lexer\";\nimport { Parser } from \"./ast.js\";\nimport { SemanticAnalyzer } from \"./analyzer.js\";\nimport { Interpreter } from \"./interpreter.js\";\nfunction main() {\n  const sourceCode = `yo a = 5; yo b = a + 10; spill \"test\";`;\n  const lexer = new Lexer(sourceCode);\n  const tokens = lexer.tokenize();\n  console.log(\"Tokens:\", tokens);\n\n  const parser = new Parser(tokens);\n  const ast = parser.parse();\n\n  console.log(JSON.stringify(ast, null, 2)); // Debugging: Print the AST structure\n\n  const semanticAnalyzer = new SemanticAnalyzer(ast);\n  semanticAnalyzer.analyze();\n  console.log(\"Semantic analysis completed successfully.\");\n  const interpreter = new Interpreter();\n  interpreter.interpret(ast);\n}\n\nmain();\n","export class Lexer {\n  constructor(input) {\n    this.input = input;\n    this.position = 0;\n    this.tokens = [];\n  }\n\n  tokenize() {\n    while (this.position < this.input.length) {\n      let char = this.input[this.position];\n\n      if (/\\s/.test(char)) {\n        this.position++;\n        continue;\n      }\n\n      switch (char) {\n        case \";\":\n          this._addToken(\"SEMICOLON\", char);\n          break;\n        case \"+\":\n          this._addToken(\"PLUS\", char);\n          break;\n        case \"-\":\n          this._addToken(\"MINUS\", char);\n          break;\n        case \"*\":\n          this._addToken(\"MULTIPLY\", char);\n          break;\n        case \"/\":\n          this._addToken(\"DIVIDE\", char);\n          break;\n        case \"%\":\n          this._addToken(\"MODULO\", char);\n          break;\n        case \"=\":\n          this._addToken(\"EQUALS\", char);\n          break;\n        case \">\":\n          this._addToken(\"GREATER_THAN\", char);\n          break;\n        case \"<\":\n          this._addToken(\"LESS_THAN\", char);\n          break;\n        case \"{\":\n          this._addToken(\"LBRACE\", char);\n          break;\n        case \"}\":\n          this._addToken(\"RBRACE\", char);\n          break;\n        case \"(\":\n          this._addToken(\"LPAREN\", char);\n          break;\n        case \")\":\n          this._addToken(\"RPAREN\", char);\n          break;\n        case \"[\":\n          this._addToken(\"LBRACKET\", char);\n          break;\n        case \"]\":\n          this._addToken(\"RBRACKET\", char);\n          break;\n        case \",\":\n          this._addToken(\"COMMA\", char);\n          break;\n        case '\"':\n          this.tokens.push(this._readString());\n          break;\n        default:\n          if (/[a-zA-Z]/.test(char)) {\n            this.tokens.push(this._readIdentifierOrKeyword());\n          } else if (/\\d/.test(char)) {\n            this.tokens.push(this._readNumber());\n          } else {\n            throw new Error(`Unexpected character: ${char}`);\n          }\n      }\n    }\n    return this.tokens;\n  }\n\n  _addToken(type, value) {\n    this.tokens.push({ type, value });\n    this.position++;\n  }\n\n  _readIdentifierOrKeyword() {\n    let start = this.position;\n    while (/[a-zA-Z]/.test(this.input[this.position])) {\n      this.position++;\n    }\n    let value = this.input.slice(start, this.position);\n    const keywords = [\n      \"yo\",\n      \"brofunc\",\n      \"bounce\",\n      \"spill\",\n      \"if\",\n      \"else\",\n      \"forEvery\",\n      \"squadGoals\",\n      \"dope\",\n      \"nope\"\n    ];\n    const type = keywords.includes(value) ? \"KEYWORD\" : \"IDENTIFIER\";\n    return { type, value };\n  }\n\n  _readNumber() {\n    let start = this.position;\n    while (/\\d/.test(this.input[this.position])) {\n      this.position++;\n    }\n    let value = this.input.slice(start, this.position);\n    return { type: \"NUMBER\", value };\n  }\n\n  _readString() {\n    let start = ++this.position; // Skip the opening quote\n    while (this.input[this.position] !== '\"') {\n      this.position++;\n    }\n    let value = this.input.slice(start, this.position);\n    this.position++; // Skip the closing quote\n    return { type: \"STRING\", value };\n  }\n}\n","class ASTNode {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n    this.children = [];\n  }\n}\n\nexport class Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.position = 0;\n  }\n\n  parse() {\n    const root = new ASTNode(\"Program\", null);\n    while (this.position < this.tokens.length) {\n      root.children.push(this._parseStatement());\n    }\n    return root;\n  }\n\n  _parseStatement() {\n    const token = this.tokens[this.position];\n    console.log(\n      `Parsing statement at position ${this.position}: ${\n        token ? token.type : \"EOF\"\n      }`\n    );\n\n    switch (token.type) {\n      case \"KEYWORD\":\n        return this._parseKeywordStatement();\n      case \"IDENTIFIER\":\n        return this._parseExpressionStatement();\n      default:\n        throw new Error(`Unexpected token: ${token.type}`);\n    }\n  }\n\n  _parseKeywordStatement() {\n    const token = this.tokens[this.position++];\n    let statementNode;\n\n    switch (token.value) {\n      case \"yo\":\n        statementNode = this._parseVariableDeclaration();\n        break;\n      case \"brofunc\":\n        statementNode = this._parseFunctionDeclaration();\n        break;\n      case \"spill\":\n        statementNode = this._parsePrintStatement();\n        break;\n      case \"if\":\n        statementNode = this._parseIfStatement();\n        break;\n      case \"forEvery\":\n        statementNode = this._parseForEachLoop();\n        break;\n      case \"squadGoals\":\n        statementNode = this._parseConcurrencyBlock();\n        break;\n      default:\n        throw new Error(`Unexpected keyword: ${token.value}`);\n    }\n\n    this._consume(\"SEMICOLON\");\n    return statementNode;\n  }\n\n  _parseVariableDeclaration() {\n    const identifierToken = this.tokens[this.position++];\n    this._consume(\"EQUALS\");\n    const expressionNode = this._parseExpression();\n    return new ASTNode(\"VariableDeclaration\", {\n      identifier: identifierToken.value,\n      expression: expressionNode\n    });\n  }\n\n  _parseFunctionDeclaration() {\n    const nameToken = this.tokens[this.position++];\n    const params = this._parseParameters();\n    const body = this._parseBlock();\n    return new ASTNode(\"FunctionDeclaration\", {\n      name: nameToken.value,\n      parameters: params,\n      body: body\n    });\n  }\n  _parsePrintStatement() {\n    const expressionNode = this._parseExpression();\n    if (!expressionNode) {\n      throw new Error(\"Failed to parse expression for spill statement\");\n    }\n    return new ASTNode(\"PrintStatement\", { expression: expressionNode });\n  }\n\n  _parseIfStatement() {\n    const condition = this._parseExpression();\n    const thenBranch = this._parseBlock();\n    let elseBranch = null;\n    if (this._match(\"KEYWORD\", \"else\")) {\n      elseBranch = this._parseBlock();\n    }\n    return new ASTNode(\"IfStatement\", {\n      condition: condition,\n      thenBranch: thenBranch,\n      elseBranch: elseBranch\n    });\n  }\n\n  _parseForEachLoop() {\n    const elementToken = this.tokens[this.position++];\n    this._consume(\"KEYWORD\", \"in\");\n    const listToken = this.tokens[this.position++];\n    const body = this._parseBlock();\n    return new ASTNode(\"ForEachLoop\", {\n      element: elementToken.value,\n      list: listToken.value,\n      body: body\n    });\n  }\n\n  _parseConcurrencyBlock() {\n    const body = this._parseBlock();\n    return new ASTNode(\"ConcurrencyBlock\", body);\n  }\n\n  _parseExpressionStatement() {\n    const expressionNode = this._parseExpression();\n    this._consume(\"SEMICOLON\");\n    return new ASTNode(\"ExpressionStatement\", expressionNode);\n  }\n  _parseExpression() {\n    let left = this._parsePrimary();\n\n    while (\n      this._check(\"PLUS\") ||\n      this._check(\"MINUS\") ||\n      this._check(\"MULTIPLY\") ||\n      this._check(\"DIVIDE\") ||\n      this._check(\"MODULO\")\n    ) {\n      const operatorToken = this.tokens[this.position++];\n      const right = this._parsePrimary();\n      left = new ASTNode(\"BinaryExpression\", {\n        operator: operatorToken.value,\n        left: left,\n        right: right\n      });\n    }\n\n    return left;\n  }\n\n  _parsePrimary() {\n    const token = this.tokens[this.position++];\n    switch (token.type) {\n      case \"IDENTIFIER\":\n        return new ASTNode(\"Identifier\", token.value);\n      case \"NUMBER\":\n      case \"STRING\":\n        return new ASTNode(\"Literal\", token.value);\n      default:\n        throw new Error(`Unexpected token in expression: ${token.type}`);\n    }\n  }\n\n  _parseParameters() {\n    const params = [];\n    this._consume(\"LPAREN\");\n    while (!this._check(\"RPAREN\")) {\n      const paramToken = this.tokens[this.position++];\n      params.push(paramToken.value);\n      if (!this._check(\"RPAREN\")) {\n        this._consume(\"COMMA\");\n      }\n    }\n    this._consume(\"RPAREN\");\n    return params;\n  }\n\n  _parseBlock() {\n    this._consume(\"LBRACE\");\n    const statements = [];\n    while (!this._check(\"RBRACE\")) {\n      statements.push(this._parseStatement());\n    }\n    this._consume(\"RBRACE\");\n    return new ASTNode(\"Block\", statements);\n  }\n  _consume(expectedType, expectedValue = null) {\n    if (this.position >= this.tokens.length) {\n      throw new Error(\n        `Unexpected end of input, expected token type ${expectedType}`\n      );\n    }\n\n    const token = this.tokens[this.position];\n    if (\n      token.type !== expectedType ||\n      (expectedValue !== null && token.value !== expectedValue)\n    ) {\n      throw new Error(\n        `Expected token type ${expectedType} but found ${token.type}`\n      );\n    }\n    this.position++;\n  }\n\n  _check(type) {\n    if (this.position >= this.tokens.length) return false;\n    return this.tokens[this.position].type === type;\n  }\n\n  _match(type, value) {\n    if (this._check(type) && this.tokens[this.position].value === value) {\n      this.position++;\n      return true;\n    }\n    return false;\n  }\n}\n","export class SemanticAnalyzer {\n  constructor(ast) {\n    this.ast = ast;\n  }\n\n  analyze() {\n    this._checkNode(this.ast);\n  }\n\n  _checkNode(node) {\n    if (node.type === \"Program\") {\n      node.children.forEach((child) => this._checkNode(child));\n    } else if (node.type === \"Expression\") {\n      // Example check: ensure identifiers are defined\n      if (!this._isDefined(node.value)) {\n        throw new Error(`Undefined identifier: ${node.value}`);\n      }\n      node.children.forEach((child) => this._checkNode(child));\n    }\n  }\n\n  _isDefined(identifier) {\n    // Placeholder for checking if an identifier is defined\n    return true;\n  }\n}\n","export class Interpreter {\n  constructor() {\n    this.variables = {};\n  }\n\n  interpret(ast) {\n    this._executeBlock(ast.children);\n  }\n\n  _executeBlock(statements) {\n    for (const statement of statements) {\n      this._execute(statement);\n    }\n  }\n\n  _execute(node) {\n    switch (node.type) {\n      case \"Program\":\n        this._executeBlock(node.children);\n        break;\n      case \"VariableDeclaration\":\n        this._executeVariableDeclaration(node);\n        break;\n      case \"PrintStatement\":\n        this._executePrintStatement(node);\n        break;\n      case \"ExpressionStatement\":\n        this._evaluate(node.value);\n        break;\n      case \"IfStatement\":\n        this._executeIfStatement(node);\n        break;\n      case \"ForEachLoop\":\n        this._executeForEachLoop(node);\n        break;\n      case \"FunctionDeclaration\":\n        this._executeFunctionDeclaration(node);\n        break;\n      case \"ConcurrencyBlock\":\n        this._executeBlock(node.value.children); // Simplified for single-thread execution\n        break;\n      default:\n        throw new Error(`Unknown node type: ${node.type}`);\n    }\n  }\n\n  _executeVariableDeclaration(node) {\n    const value = this._evaluate(node.value.expression);\n    this.variables[node.value.identifier] = value;\n  }\n\n  _executePrintStatement(node) {\n    const value = this._evaluate(node.value.expression);\n    console.log(value);\n  }\n\n  _executeIfStatement(node) {\n    const condition = this._evaluate(node.value.condition);\n    if (condition) {\n      this._executeBlock(node.value.thenBranch.children);\n    } else if (node.value.elseBranch) {\n      this._executeBlock(node.value.elseBranch.children);\n    }\n  }\n\n  _executeForEachLoop(node) {\n    const list = this.variables[node.value.list];\n    for (const item of list) {\n      this.variables[node.value.element] = item;\n      this._executeBlock(node.value.body.children);\n    }\n  }\n\n  _executeFunctionDeclaration(node) {\n    // Store function in variables for later invocation\n    this.variables[node.value.name] = node;\n  }\n\n  _evaluate(node) {\n    if (!node) {\n      throw new Error(\"Attempted to evaluate a null or undefined node\");\n    }\n    console.log(\"Evaluating node:\", node);\n    switch (node.type) {\n      case \"Literal\":\n        return node.value;\n      case \"BinaryExpression\":\n        return this._evaluateBinaryExpression(node);\n      case \"Identifier\":\n        return this.variables[node.value];\n      default:\n        throw new Error(`Unknown node type in evaluation: ${node.type}`);\n    }\n  }\n\n  _evaluateBinaryExpression(node) {\n    const left = this._evaluate(node.value.left);\n    const right = this._evaluate(node.value.right);\n    switch (node.value.operator) {\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"%\":\n        return left % right;\n      default:\n        throw new Error(`Unknown operator: ${node.value.operator}`);\n    }\n  }\n}\n"],"names":["$df8b4d8c99c86b58$export$6168dc8908a6c652","constructor","input","position","tokens","tokenize","length","char","test","_addToken","push","_readString","_readIdentifierOrKeyword","_readNumber","Error","type","value","start","slice","keywords","includes","$bcf4dc5857a381cb$var$ASTNode","children","$bcf4dc5857a381cb$export$7acfa6ed01010e37","parse","root","_parseStatement","token","console","log","_parseKeywordStatement","_parseExpressionStatement","statementNode","_parseVariableDeclaration","_parseFunctionDeclaration","_parsePrintStatement","_parseIfStatement","_parseForEachLoop","_parseConcurrencyBlock","_consume","identifierToken","expressionNode","_parseExpression","identifier","expression","nameToken","params","_parseParameters","body","_parseBlock","name","parameters","condition","thenBranch","elseBranch","_match","elementToken","listToken","element","list","left","_parsePrimary","_check","operatorToken","right","operator","paramToken","statements","expectedType","expectedValue","$b96d835da55fc0cb$export$703935dce4376685","ast","analyze","_checkNode","node","forEach","child","_isDefined","$39fe91971e2ac260$export$e5b52c46a548ff03","variables","interpret","_executeBlock","statement","_execute","_executeVariableDeclaration","_executePrintStatement","_evaluate","_executeIfStatement","_executeForEachLoop","_executeFunctionDeclaration","item","_evaluateBinaryExpression","$959637dd9f50fb12$var$main","lexer","parser","JSON","stringify","semanticAnalyzer","interpreter"],"version":3,"file":"index.4c084828.js.map"}