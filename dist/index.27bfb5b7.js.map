{"mappings":"","sources":["brolang.js","ast.js","lexer.js","analyzer.js"],"sourcesContent":["import { Parser } from \"./ast\";\nimport { Lexer } from \"./lexer\";\nimport { SemanticAnalyzer } from \"./analyzer\";\n","class ASTNode {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n    this.children = [];\n  }\n}\n\nexport class Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.position = 0;\n  }\n\n  parse() {\n    const root = new ASTNode(\"Program\", null);\n    while (this.position < this.tokens.length) {\n      root.children.push(this._parseStatement());\n    }\n    return root;\n  }\n\n  _parseStatement() {\n    const token = this.tokens[this.position];\n    if (token.type === \"IDENTIFIER\") {\n      return this._parseExpression();\n    }\n    throw new Error(`Unexpected token: ${token.type}`);\n  }\n\n  _parseExpression() {\n    const token = this.tokens[this.position++];\n    const node = new ASTNode(\"Expression\", token.value);\n    if (\n      this.tokens[this.position] &&\n      this.tokens[this.position].type === \"PLUS\"\n    ) {\n      this.position++;\n      node.children.push(this._parseExpression());\n    }\n    return node;\n  }\n}\n","export class Lexer {\n    constructor(input) {\n      this.input = input;\n      this.position = 0;\n      this.tokens = [];\n    }\n  \n    tokenize() {\n      while (this.position < this.input.length) {\n        let char = this.input[this.position];\n  \n        if (/\\s/.test(char)) {\n          this.position++;\n          continue;\n        }\n  \n        switch (char) {\n          case ';':\n            this._addToken('SEMICOLON', char);\n            break;\n          case '+':\n            this._addToken('PLUS', char);\n            break;\n          default:\n            if (/[a-zA-Z]/.test(char)) {\n              this.tokens.push(this._readIdentifier());\n            } else if (/\\d/.test(char)) {\n              this.tokens.push(this._readNumber());\n            } else {\n              throw new Error(`Unexpected character: ${char}`);\n            }\n        }\n      }\n      return this.tokens;\n    }\n  \n    _addToken(type, value) {\n      this.tokens.push({ type, value });\n      this.position++;\n    }\n  \n    _readIdentifier() {\n      let start = this.position;\n      while (/[a-zA-Z]/.test(this.input[this.position])) {\n        this.position++;\n      }\n      let value = this.input.slice(start, this.position);\n      return { type: 'IDENTIFIER', value };\n    }\n  \n    _readNumber() {\n      let start = this.position;\n      while (/\\d/.test(this.input[this.position])) {\n        this.position++;\n      }\n      let value = this.input.slice(start, this.position);\n      return { type: 'NUMBER', value };\n    }\n  }\n  ","export class SemanticAnalyzer {\n  constructor(ast) {\n    this.ast = ast;\n  }\n\n  analyze() {\n    this._checkNode(this.ast);\n  }\n\n  _checkNode(node) {\n    if (node.type === \"Program\") {\n      node.children.forEach((child) => this._checkNode(child));\n    } else if (node.type === \"Expression\") {\n      // Example check: ensure identifiers are defined\n      if (!this._isDefined(node.value)) {\n        throw new Error(`Undefined identifier: ${node.value}`);\n      }\n      node.children.forEach((child) => this._checkNode(child));\n    }\n  }\n\n  _isDefined(identifier) {\n    // Placeholder for checking if an identifier is defined\n    return true;\n  }\n}\n"],"names":[],"version":3,"file":"index.27bfb5b7.js.map"}